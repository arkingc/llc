## 下列情况合成析构函数是删除的

* 如果类的**某个成员的析构函数是删除的或不可访问**的(如private)；

## 下列情况合成拷贝函数是删除的

* 如果类的**某个成员的拷贝构造函数是删除的或不可访问**的
* 如果类的**某个成员的析构函数是删除的或不可访问**的
* 如果类定义了**移动操作(移动构造或移动赋值)**

## 下列情况合成赋值运算符是删除的

* 如果类的**某个成员的拷贝赋值运算符是删除的或不可访问**的
* 类有一个**const或引用成员**
* 如果类定义了**移动操作(移动构造或移动赋值)**

虽然可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

## 下列情况移动操作(移动拷贝与移动赋值)是删除的

总的来说，移动操作永远不会隐式定义为删除的函数，除非 显示地要求编译器生成=default的移动构造函数，但编译器又不能移动所有成员时。下列情况，无法移动成员：

* 类成员**定义了**自己的**拷贝构造函数**且**未定义移动构造函数**(不会合成)。或类成员**没定义**自己的**拷贝构造函数但**编译器**无法合成**
* 类成员的**移动构造函数**或**移动赋值运算符**被定义为**删除的或是不可访问**的
* **析构函数**被定义为**删除的或不可访问**的
* 类似拷贝赋值运算符，如果有类成员是**const或引用**，则**移动赋值运算符**被定义为删除的

如果没有=default声明，或者编译器忽略了，在这种情况下，如果移动操作**可能**被定义为删除的函数，编译器就不会合成它们。

## 下列情况合成默认构造函数是删除的

* 如果类的**某个成员的析构函数是删除的或不可访问**的
* 类有一个**没有类内初始值(类内初始化器)的引用成员**
* 类有一个**没有类内初始值的const成员，且其类型未显示定义默认构造函数**
